<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="aZ679hf2Rw"><title> 我是思聪</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/prontera.css"><link rel="search" type="application/opensearchdescription+xml" href="http://www.april1985.com/atom.xml" title="我是思聪"><!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-129409069-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129409069-1');
</script>


<script>
  (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();
  </script></head><body><header class="feature-header"><nav class="component-nav"><ul><div class="logo-container"><a href="/"><h2 class="title">我是思聪</h2></a></div><a href="/" target="_self" class="li component-nav-item"><p>现在</p></a><a href="/archives" target="_self" class="li component-nav-item"><p>曾经</p></a><ul class="shortcut-icons"><a href="https://github.com/derekhe" target="_blank"><img src="/images/github.svg" class="icon"></a><a href="/atom.xml" target="_blank"><img src="/images/rss.svg" class="icon"></a></ul></ul></nav></header><main class="container"><div id="body-container"><div id="post-list" class="left"><div class="home post-list"><div class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/post/2007-06-06-openscenegraph-notes-c-cli-to-write-managed-scene-class/" class="post-title-link">OpenSceneGraph 笔记--C++/CLI写托管Scene类</a></h2><div class="post-info">Jun 6, 2007</div><div class="post-content"><p>最近学了C++/CLI，也写了一些小玩意儿体验了它的强大，昨天开始筹划将以前的弯管机的模拟程序用C++/CLI重写。</p>
<p>基本思路是将底层3D部分和上层GUI图形界面部分大体分离。最原始的做法是写一个C++的类，然后定义一些接口，然后用C++/CLI写一个Wrapper，然后用C#进行调用。这种做法其实不是很好，增加了很大的工作量，而且在写Wrapper的时候难免有很多重复性的赋值代码。</p>
<p>第二种思路就是直接用C++/CLI开始写，将Native部分和Managed部分合并在一块儿写。当然C++/CLI有一些限制，不能在托管类里面直接嵌套非托管类，只能有非托管类的指针等等。这个限制带来的最大的不好是osg::ref_ptr，也就是OpenSceneGraph里面的智能指针无法使用了，因为他是一个类型，不能直接嵌入到托管类里面，所以类似下面的语法是错误的：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ref</span> class ManagedClass</span><br><span class="line">&#123;</span><br><span class="line">    osg::ref_ptr <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">&#125;</span></span><br></pre></td></tr></table></figure>

<p>当然这样写是正确的：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ref</span> class ManagedClass</span><br><span class="line">&#123;</span><br><span class="line">    osg::<span class="keyword">Node</span><span class="title">* node</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这样就失去了智能指针的保护，很容易造成内存泄露，所以当务之急是需要写一个智能指针来代替osg::ref_ptr，但基本上要保持功能的不变。OpenSceneGraph的引用类都是继承与osg::Object，而osg::Object又是继承于osg::Reference。所以这些引用类都有ref()和unref()方法，用于增加和减少ReferenceCount，当ReferenceCount=0时，就自动delete了。</p>
<p>参考osg::ref_ptr并去掉这个类中不常用的部分，写了一个smart_ptr类，完成了智能指针的任务：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//! OpenSceneGraph managed smart_ptr.</span></span><br><span class="line">template</span><br><span class="line"><span class="keyword">public</span> ref <span class="class"><span class="keyword">class</span> <span class="title">smart_ptr</span></span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">typedef T element_type;</span><br><span class="line"></span><br><span class="line">smart_ptr() : _ptr(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">smart_ptr(T* ptr) : _ptr(ptr) &#123; <span class="keyword">if</span> (_ptr) _ptr-&gt;ref(); &#125;</span><br><span class="line">smart_ptr(<span class="keyword">const</span> smart_ptr% rp) : _ptr(rp._ptr) &#123; <span class="keyword">if</span> (_ptr) _ptr-&gt;ref(); &#125;</span><br><span class="line"></span><br><span class="line">~smart_ptr() &#123; <span class="keyword">if</span> (_ptr) _ptr-&gt;unref();  _ptr = <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">smart_ptr% <span class="keyword">operator</span> = (<span class="keyword">const</span> smart_ptr% rp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_ptr==rp._ptr) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">T* tmp_ptr = _ptr;</span><br><span class="line">_ptr = rp._ptr;</span><br><span class="line"><span class="keyword">if</span> (_ptr) _ptr-&gt;ref();</span><br><span class="line"><span class="comment">// unref second to prevent any deletion of any object which might</span></span><br><span class="line"><span class="comment">// be referenced by the other object. i.e rp is child of the</span></span><br><span class="line"><span class="comment">// original _ptr.</span></span><br><span class="line"><span class="keyword">if</span> (tmp_ptr) tmp_ptr-&gt;unref();</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> smart_ptr% <span class="keyword">operator</span> = (T* ptr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_ptr==ptr) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">T* tmp_ptr = _ptr;</span><br><span class="line">_ptr = ptr;</span><br><span class="line"><span class="keyword">if</span> (_ptr) _ptr-&gt;ref();</span><br><span class="line"><span class="comment">// unref second to prevent any deletion of any object which might</span></span><br><span class="line"><span class="comment">// be referenced by the other object. i.e rp is child of the</span></span><br><span class="line"><span class="comment">// original _ptr.</span></span><br><span class="line"><span class="keyword">if</span> (tmp_ptr) tmp_ptr-&gt;unref();</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//T% operator*()  &#123; return *_ptr; &#125;</span></span><br><span class="line">T* <span class="keyword">operator</span>-&gt;()  &#123; <span class="keyword">return</span> _ptr; &#125;</span><br><span class="line">T* <span class="keyword">get</span>()  &#123; <span class="keyword">return</span> _ptr; &#125;</span><br><span class="line"></span><br><span class="line">bool <span class="keyword">operator</span>!()    &#123; <span class="keyword">return</span> _ptr==<span class="number">0</span>; &#125; <span class="comment">// not required</span></span><br><span class="line">bool valid()        &#123; <span class="keyword">return</span> _ptr!=<span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">T* release() &#123; T* tmp=_ptr; <span class="keyword">if</span> (_ptr) _ptr-&gt;unref_nodelete(); _ptr=<span class="number">0</span>; <span class="keyword">return</span> tmp; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* _ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如此这般折腾以后，终于可以在托管类中间使用智能指针了：</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">ref</span> <span class="keyword">class</span> <span class="title">Scene</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line">smart_ptr gc;</span><br><span class="line">smart_ptr root;</span><br><span class="line">smart_ptr viewer;</span><br><span class="line">smart_ptr camera;</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>跨越了智能指针的障碍以后，还有很多问题有待于解决。像osg::Vec3这些常用类只能重写以便于调用。像查找节点FindNode这种函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ref <span class="class"><span class="keyword">class</span> <span class="title">NodeFound</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">String^ name;</span><br><span class="line">smart_ptr osgNode;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">NodeFound^ FindNode(String^ name)</span><br><span class="line">&#123;</span><br><span class="line">FindNodeVisitor findNodeVisitor;</span><br><span class="line">findNodeVisitor.name=MarshalString(name);</span><br><span class="line">root-&gt;accept(findNodeVisitor);</span><br><span class="line"><span class="keyword">if</span>(findNodeVisitor.node==<span class="literal">NULL</span>) <span class="keyword">throw</span> gcnew Exceptions::NodeNotFoundExpection();</span><br><span class="line"></span><br><span class="line">NodeFound^ nodeFound=gcnew NodeFound();</span><br><span class="line">nodeFound-&gt;name=name;</span><br><span class="line">nodeFound-&gt;osgNode=findNodeVisitor.node;</span><br><span class="line"><span class="keyword">return</span> nodeFound;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只能定义一个新的结构作为返回值，否则C#语言无法使用，因为它不能解析一个智能指针。……或许，还有别的方法可以用吧，比如用IntPtr这种，但可能又会脱离了智能指针的保护，变的危险起来。</p>
</div></article></div><div class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/post/2007-06-04-graduation/" class="post-title-link">毕业设计~</a></h2><div class="post-info">Jun 4, 2007</div><div class="post-content"><p>还有二十几天就要毕业了，大家也开始”忙着“写毕业设计论文了。至于本科生的毕业设计论文我也不想说太多的东西，因为大家心知肚明，老师什么态度、学生什么态度，3万字的论文实际含金量有多少，参考文献到底有没有看过。说实话，自己的毕业设计论文也是东凑西凑的，比起原来写的2万字的那个文档快活了许多。</p>
<p>倒是我自己的态度和其他同学不一样——先做再玩。</p>
<p>自己有一个很好的”特性“，呵呵，Feature，就是什么事情都会快节奏的做完，然后再做其他的事情，效率很高，自己一天也玩得痛快。喜欢独立的思考，不喜欢一天到晚精力旺盛大吼大叫，这种类型的人我们寝室倒是有，没办法，别人就是一天睡3个小时也是旺盛得不得了。昨天就没有睡好，晚上两个人在下面“疯狂打字员”，键盘敲得特别响，把我吵醒了！烦人，还好我的键盘是基本静音的，而且我会考虑到别人的感受，做什么事情都悄悄的。</p>
<p>倒是我觉得毕业了，微软公司也应该给每个人发一个WORD三级证书了，学校把格式要求得很严，然后大家都不管写什么啦，都调格式啦，WORD文档做得相当漂亮，这时候，微软笑了！</p>
<p>过了这个村，还有一个庙，不知道研究生阶段，写论文，是个什么样子！<del>唉，学术腐败啊</del></p>
<p>记得写论文基本成型以后，用SVN做管理，避免以后论文改得不像话了而找不到原文件了。</p>
<p>……头晕晕的，睡觉去……~</p>
</div></article></div><div class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/post/2007-06-03-my-del-icio-us/" class="post-title-link">My del.icio.us</a></h2><div class="post-info">Jun 3, 2007</div><div class="post-content"><p>自从用了Firefox就一直用Google Brower Sync这个工具来同步我的收藏夹，但总是觉得每次打开和关闭的时候都在进行同步，有时候会卡住，弄不好Firefox就没有响应了。在网络无法链接Google的时候(此刻鄙视润新和联通！)，就无法同步了。而且同步还会遇到两个电脑上进行同步后的收藏夹莫名其妙丢失的情况。</p>
<p>最后还是卸载了这个用了很久的工具。</p>
<p>换成yahoo的del.icio.us了，超级方便快捷强大的收藏夹。这个网络收藏夹做到了和浏览器的整合，而且提供了了强大的查询、共享机制。访问我的收藏夹也变得如此简单：</p>
<p><a href="http://del.icio.us/hesicong2007" target="_blank" rel="noopener">http://del.icio.us/hesicong2007</a></p>
<p>值的一提的是，这个域名取得很帅！del.icio.us，通过点分割单词以后的域名很好记，也正好符合域名注册的需要，更重要的是只需要记住delicious这个单词，外加一个你的用户名就可以访问到收藏夹了……相当人性化的设计啊！</p>
</div></article></div><div class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/post/2007-05-31-bf2142-latest-record/" class="post-title-link">BF2142最新战绩</a></h2><div class="post-info">May 31, 2007</div><div class="post-content"><p>哇哇哇……几个小时就得了第一、第二、第三……全部齐全了，更奇怪的是得了一个瞄准协助勋章……想当时正在扔手雷，奇怪。还得了一个泰坦终结者勋章……还有什么勋章来着……哇，太多了。</p>
<p>主要因素还在于服务器比较卡，我都卡成习惯了，提前量把握得比较好，平时没事的时候就开小车到处夺旗赚分。还有就是维修泰坦，但是发现维修到一定程度以后分数便不会在长了，应该是游戏防止恶意刷分的。</p>
<p>还是不错拉，上网卡还有一点点钱了，大概最近不玩了，把毕业设计的东西搞定再说：)</p>
</div></article></div><div class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/post/2007-05-25-deceived/" class="post-title-link">被骗了</a></h2><div class="post-info">May 25, 2007</div><div class="post-content"><p>科林麦克雷：尘埃发布DEMO版了，本来很期待看一看“最低质量”是什么效果，结果这个破游戏连进入游戏都不行。官方最低配置6800，而我只有一个6600GT。再到游侠网上面看一看结果8800GTX这样猛的显卡在ULTRA画质下面只有个位数的FPS！！！这样还玩个毛线。</p>
<p>对比于同时间下载的虚幻4引擎的DEMO，明显要比这个游戏温柔得多，好歹6600GT在稍微降低一些HDR效果之类的特效以后还能跑到30FPS以上，画质还能接受呢。开了所有特效以后也不是那种幻灯片，至少还有10FPS以上的速度。</p>
<p>不知道是不是PC游戏开发厂商头脑发热了，前段时间玩过TestDrive:Unlimited，我这个卡只能开640<em>480，全低，256MB显存是标配。什么玩意儿哦！我看这个破游戏的贴图也没有什么精致的嘛，要那么多显存来干什么？分辨率1024</em>768即便是几次渲染也没有那么恐怖的的显存占用啊！！！！</p>
<p>还有SupreCommander，这也是个破游戏……1280*1024的分辨率都不够那些千千万万的图标满天飞。对CPU要求也很高。而且更郁闷的是建议配置两个显示器！！！！靠……</p>
<p>还是XBOX360好，X800等级的显卡，不算很强的CPU，尘埃都能运行得很好……还是游戏机好，2千5就能买一个360了，这个价格只够一个8800GTS的价格，而8800GTS尘埃还能不能动还成问题！</p>
<p>就不能优化一下么？物理引擎的开销就不能小一点么？用硬件的性能来抵消优化的时间，这本来是一个可取之道，但是……………………这些厂商也做得太过火了吧！</p>
<p>算了，还是玩玩NFS. BF2142之类的，游戏画质已经够满意了，游戏性更不用说！</p>
<p>那些破游戏厂商，赶快倒闭！！！！！！</p>
<p>下面是虚幻4引擎实际运行画面的截图：<br>HDR蜡烛<br><a href="/images/others/00000.jpg"></a><img src="/images/others/image/thumb/00000.jpg" alt></p>
<p>DOF(Depth of Field)景深效果，多次渲染而成。<br><a href="/images/others/00001.jpg"></a><img src="/images/others/image/thumb/00001.jpg" alt></p>
<p>PostProcess，画面后期处理，这个其实就类似于Photoshop。这个需要Pixel Shader的处理。<br><a href="/images/others/00013.jpg"></a><img src="/images/others/image/thumb/00013.jpg" alt></p>
<p><a href="/images/others/00017.jpg"></a><img src="/images/others/image/thumb/00017.jpg" alt></p>
<p><a href="/images/others/00023.jpg"></a><img src="/images/others/image/thumb/00023.jpg" alt></p>
<p><a href="/images/others/00029.jpg"></a><img src="/images/others/image/thumb/00029.jpg" alt></p>
</div></article></div></div></div><div id="sidebar" class="left"><div id="about-panel"><div class="info"><div class="title">贺思聪</div><div class="bio">《爬虫实战：从数据到产品》作者，国内首个机票价格历史及预测小程序“爱飞狗旅行”作者，极客、架构师、大数据玩家。</div></div><img src="/images/avatar.png" class="avatar"></div><div id="friend-links-panel"><div class="panel-title"><p>LINKS</p></div><a href="http://github.com/derekhe" target="_blank" class="link-item"><div class="link-container"><div class="site-name">GitHub</div><div class="site-desc">http://github.com/derekhe</div></div></a><a href="http://www.jianshu.com/u/b1e713e56ea6" target="_blank" class="link-item"><div class="link-container"><div class="site-name">简书</div><div class="site-desc">http://www.jianshu.com/u/b1e713e56ea6</div></div></a><a href="https://www.linkedin.com/in/sicong-he-56a95437/" target="_blank" class="link-item"><div class="link-container"><div class="site-name">LinkedIn</div><div class="site-desc">https://www.linkedin.com/in/sicong-he-56a95437/</div></div></a></div></div></div><div class="clear"></div></main><footer class="footer-container"><div class="paginator"><a href="/page/91/" class="prev">PREV</a><a href="/page/93/" class="next">NEXT</a></div><div class="copyright"><p>© 2008 - 2019 <a href="http://www.april1985.com">贺思聪</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/AngryPowman/hexo-theme-prontera" target="_blank">hexo-theme-prontera</a>.</p></div></footer><script>var _mtac = {}; (function() {     var mta = document.createElement("script"); mta.src = "http://pingjs.qq.com/h5/stats.js?v2.0.2";    mta.setAttribute("name", "MTAH5");    mta.setAttribute("sid", "500490740");    var s = document.getElementsByTagName("script")[0];    s.parentNode.insertBefore(mta, s);})();</script></body></html>