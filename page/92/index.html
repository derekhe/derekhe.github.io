<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="aZ679hf2Rw"><title> 我是思聪</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/prontera.css"><link rel="search" type="application/opensearchdescription+xml" href="http://www.april1985.com/atom.xml" title="我是思聪"><!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-129409069-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129409069-1');
</script>


<script>
  (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();
  </script></head><body><header class="feature-header"><nav class="component-nav"><ul><div class="logo-container"><a href="/"><h2 class="title">我是思聪</h2></a></div><a href="/" target="_self" class="li component-nav-item"><p>现在</p></a><a href="/archives" target="_self" class="li component-nav-item"><p>曾经</p></a><ul class="shortcut-icons"><a href="https://github.com/derekhe" target="_blank"><img src="/images/github.svg" class="icon"></a><a href="/atom.xml" target="_blank"><img src="/images/rss.svg" class="icon"></a></ul></ul></nav></header><main class="container"><div id="body-container"><div id="post-list" class="left"><div class="home post-list"><div class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/post/2007-06-10-i-still-remember-the-summer-you-and-me/" class="post-title-link">I STILL REMEMBER - THE SUMMER - YOU AND ME</a></h2><div class="post-info">Jun 10, 2007</div><div class="post-content"><p>毕业前夕<br>记忆中<br>还有那年<br>你我的影子<br><a href="/images/2007-6-10/IMG_0934-RESIZED.jpg"></a><img src="/images/2007-6-10/image/thumb/IMG_0934-RESIZED.jpg" alt></p>
</div></article></div><div class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/post/2007-06-08-play-games-these-days/" class="post-title-link">这几天玩游戏</a></h2><div class="post-info">Jun 8, 2007</div><div class="post-content"><p>论文写完了，PPT做完了，程序不想写了，无聊了，就玩游戏了~</p>
<p>装上最新的“蜘蛛侠3”游戏，玩了3天时间，9个多小时基本上就搞定了。画面质量还算中等，令人印象比较深刻的是其大量使用的凹凸贴图，爬到墙上的时候就会发现纹理很清晰，怪不得这个游戏最低配置是Geforce 6系列的，在我这个6600GT上只能开800X600其他全低。但是其实开到最高也没有感觉游戏画面有多少的进步，反而是帧数下降得相当厉害。落后拉~</p>
<p>蜘蛛侠3的动作做的挺好的，操作也比较容易上手，前提是图像要流畅……~要不然一吐丝，一个转向，人都不知道飞到哪儿去了……整个游戏玩下来基本上还是保持在20帧附近吧，很多场景的相当之不流畅，唉。之前有一个化学工厂的场景，也就是一秒钟一幅画的水平，也没有觉得画面有多么的复杂。开一个闸门的时候，望着远处的城市我就心酸啊，1秒钟一幅画，我开闸要开到何时啊！重试很多次以后终于放弃了。换了最新的94.71驱动，进去玩，结果就对了。</p>
<p>打沙怪的时候才心烦，第一次哈瑞打沙怪的时候就是一帧一帧的像是放幻灯片，然后这个时候还要你一系列的按键……如果按错了，还得从头再来……！！天啊，简直就是折磨人啊！后来一怒之下把驱动程序换成了NVIDIA给测试人员玩的驱动，结果……<del>基本上还可以玩了，应该说是基本流畅的玩！！！玩个游戏换了两次驱动…………………………</del></p>
<p>最后通关之前和毒蜘蛛玩的时候才造孽啊，好卡啊，动作都不到位，基本上保持在5幅画面每秒吧…………</p>
<p>终于还是通关了，卸载了，再也不玩了，虽然情节很棒，可是……真不如看漫画。</p>
<p>卸载之后又把最新的古墓丽影10周年纪念版给装上了，太搞笑了，4个G的游戏，结果基本剧情和一代差不多，隐隐约约都有印象的，图像我就不说什么了，劳拉看来也是真的老了，还不如老的一代，真是悲哀啊，EIDOS估计再也拿不出什么好玩的玩意儿给人了吧！20分钟时间，体验了第一个关卡就把它删除了，实在是无聊…………………………</p>
<p>这下没有游戏玩了，不玩了，该研究什么研究什么去</p>
</div></article></div><div class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/post/2007-06-06-openscenegraph-notes-c-cli-to-write-managed-scene-class/" class="post-title-link">OpenSceneGraph 笔记--C++/CLI写托管Scene类</a></h2><div class="post-info">Jun 6, 2007</div><div class="post-content"><p>最近学了C++/CLI，也写了一些小玩意儿体验了它的强大，昨天开始筹划将以前的弯管机的模拟程序用C++/CLI重写。</p>
<p>基本思路是将底层3D部分和上层GUI图形界面部分大体分离。最原始的做法是写一个C++的类，然后定义一些接口，然后用C++/CLI写一个Wrapper，然后用C#进行调用。这种做法其实不是很好，增加了很大的工作量，而且在写Wrapper的时候难免有很多重复性的赋值代码。</p>
<p>第二种思路就是直接用C++/CLI开始写，将Native部分和Managed部分合并在一块儿写。当然C++/CLI有一些限制，不能在托管类里面直接嵌套非托管类，只能有非托管类的指针等等。这个限制带来的最大的不好是osg::ref_ptr，也就是OpenSceneGraph里面的智能指针无法使用了，因为他是一个类型，不能直接嵌入到托管类里面，所以类似下面的语法是错误的：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ref</span> class ManagedClass</span><br><span class="line">&#123;</span><br><span class="line">    osg::ref_ptr <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">&#125;</span></span><br></pre></td></tr></table></figure>

<p>当然这样写是正确的：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ref</span> class ManagedClass</span><br><span class="line">&#123;</span><br><span class="line">    osg::<span class="keyword">Node</span><span class="title">* node</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这样就失去了智能指针的保护，很容易造成内存泄露，所以当务之急是需要写一个智能指针来代替osg::ref_ptr，但基本上要保持功能的不变。OpenSceneGraph的引用类都是继承与osg::Object，而osg::Object又是继承于osg::Reference。所以这些引用类都有ref()和unref()方法，用于增加和减少ReferenceCount，当ReferenceCount=0时，就自动delete了。</p>
<p>参考osg::ref_ptr并去掉这个类中不常用的部分，写了一个smart_ptr类，完成了智能指针的任务：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//! OpenSceneGraph managed smart_ptr.</span></span><br><span class="line">template</span><br><span class="line"><span class="keyword">public</span> ref <span class="class"><span class="keyword">class</span> <span class="title">smart_ptr</span></span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">typedef T element_type;</span><br><span class="line"></span><br><span class="line">smart_ptr() : _ptr(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">smart_ptr(T* ptr) : _ptr(ptr) &#123; <span class="keyword">if</span> (_ptr) _ptr-&gt;ref(); &#125;</span><br><span class="line">smart_ptr(<span class="keyword">const</span> smart_ptr% rp) : _ptr(rp._ptr) &#123; <span class="keyword">if</span> (_ptr) _ptr-&gt;ref(); &#125;</span><br><span class="line"></span><br><span class="line">~smart_ptr() &#123; <span class="keyword">if</span> (_ptr) _ptr-&gt;unref();  _ptr = <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">smart_ptr% <span class="keyword">operator</span> = (<span class="keyword">const</span> smart_ptr% rp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_ptr==rp._ptr) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">T* tmp_ptr = _ptr;</span><br><span class="line">_ptr = rp._ptr;</span><br><span class="line"><span class="keyword">if</span> (_ptr) _ptr-&gt;ref();</span><br><span class="line"><span class="comment">// unref second to prevent any deletion of any object which might</span></span><br><span class="line"><span class="comment">// be referenced by the other object. i.e rp is child of the</span></span><br><span class="line"><span class="comment">// original _ptr.</span></span><br><span class="line"><span class="keyword">if</span> (tmp_ptr) tmp_ptr-&gt;unref();</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> smart_ptr% <span class="keyword">operator</span> = (T* ptr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_ptr==ptr) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">T* tmp_ptr = _ptr;</span><br><span class="line">_ptr = ptr;</span><br><span class="line"><span class="keyword">if</span> (_ptr) _ptr-&gt;ref();</span><br><span class="line"><span class="comment">// unref second to prevent any deletion of any object which might</span></span><br><span class="line"><span class="comment">// be referenced by the other object. i.e rp is child of the</span></span><br><span class="line"><span class="comment">// original _ptr.</span></span><br><span class="line"><span class="keyword">if</span> (tmp_ptr) tmp_ptr-&gt;unref();</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//T% operator*()  &#123; return *_ptr; &#125;</span></span><br><span class="line">T* <span class="keyword">operator</span>-&gt;()  &#123; <span class="keyword">return</span> _ptr; &#125;</span><br><span class="line">T* <span class="keyword">get</span>()  &#123; <span class="keyword">return</span> _ptr; &#125;</span><br><span class="line"></span><br><span class="line">bool <span class="keyword">operator</span>!()    &#123; <span class="keyword">return</span> _ptr==<span class="number">0</span>; &#125; <span class="comment">// not required</span></span><br><span class="line">bool valid()        &#123; <span class="keyword">return</span> _ptr!=<span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">T* release() &#123; T* tmp=_ptr; <span class="keyword">if</span> (_ptr) _ptr-&gt;unref_nodelete(); _ptr=<span class="number">0</span>; <span class="keyword">return</span> tmp; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* _ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如此这般折腾以后，终于可以在托管类中间使用智能指针了：</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">ref</span> <span class="keyword">class</span> <span class="title">Scene</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line">smart_ptr gc;</span><br><span class="line">smart_ptr root;</span><br><span class="line">smart_ptr viewer;</span><br><span class="line">smart_ptr camera;</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>跨越了智能指针的障碍以后，还有很多问题有待于解决。像osg::Vec3这些常用类只能重写以便于调用。像查找节点FindNode这种函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ref <span class="class"><span class="keyword">class</span> <span class="title">NodeFound</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">String^ name;</span><br><span class="line">smart_ptr osgNode;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">NodeFound^ FindNode(String^ name)</span><br><span class="line">&#123;</span><br><span class="line">FindNodeVisitor findNodeVisitor;</span><br><span class="line">findNodeVisitor.name=MarshalString(name);</span><br><span class="line">root-&gt;accept(findNodeVisitor);</span><br><span class="line"><span class="keyword">if</span>(findNodeVisitor.node==<span class="literal">NULL</span>) <span class="keyword">throw</span> gcnew Exceptions::NodeNotFoundExpection();</span><br><span class="line"></span><br><span class="line">NodeFound^ nodeFound=gcnew NodeFound();</span><br><span class="line">nodeFound-&gt;name=name;</span><br><span class="line">nodeFound-&gt;osgNode=findNodeVisitor.node;</span><br><span class="line"><span class="keyword">return</span> nodeFound;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只能定义一个新的结构作为返回值，否则C#语言无法使用，因为它不能解析一个智能指针。……或许，还有别的方法可以用吧，比如用IntPtr这种，但可能又会脱离了智能指针的保护，变的危险起来。</p>
</div></article></div><div class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/post/2007-06-04-graduation/" class="post-title-link">毕业设计~</a></h2><div class="post-info">Jun 4, 2007</div><div class="post-content"><p>还有二十几天就要毕业了，大家也开始”忙着“写毕业设计论文了。至于本科生的毕业设计论文我也不想说太多的东西，因为大家心知肚明，老师什么态度、学生什么态度，3万字的论文实际含金量有多少，参考文献到底有没有看过。说实话，自己的毕业设计论文也是东凑西凑的，比起原来写的2万字的那个文档快活了许多。</p>
<p>倒是我自己的态度和其他同学不一样——先做再玩。</p>
<p>自己有一个很好的”特性“，呵呵，Feature，就是什么事情都会快节奏的做完，然后再做其他的事情，效率很高，自己一天也玩得痛快。喜欢独立的思考，不喜欢一天到晚精力旺盛大吼大叫，这种类型的人我们寝室倒是有，没办法，别人就是一天睡3个小时也是旺盛得不得了。昨天就没有睡好，晚上两个人在下面“疯狂打字员”，键盘敲得特别响，把我吵醒了！烦人，还好我的键盘是基本静音的，而且我会考虑到别人的感受，做什么事情都悄悄的。</p>
<p>倒是我觉得毕业了，微软公司也应该给每个人发一个WORD三级证书了，学校把格式要求得很严，然后大家都不管写什么啦，都调格式啦，WORD文档做得相当漂亮，这时候，微软笑了！</p>
<p>过了这个村，还有一个庙，不知道研究生阶段，写论文，是个什么样子！<del>唉，学术腐败啊</del></p>
<p>记得写论文基本成型以后，用SVN做管理，避免以后论文改得不像话了而找不到原文件了。</p>
<p>……头晕晕的，睡觉去……~</p>
</div></article></div><div class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/post/2007-06-03-my-del-icio-us/" class="post-title-link">My del.icio.us</a></h2><div class="post-info">Jun 3, 2007</div><div class="post-content"><p>自从用了Firefox就一直用Google Brower Sync这个工具来同步我的收藏夹，但总是觉得每次打开和关闭的时候都在进行同步，有时候会卡住，弄不好Firefox就没有响应了。在网络无法链接Google的时候(此刻鄙视润新和联通！)，就无法同步了。而且同步还会遇到两个电脑上进行同步后的收藏夹莫名其妙丢失的情况。</p>
<p>最后还是卸载了这个用了很久的工具。</p>
<p>换成yahoo的del.icio.us了，超级方便快捷强大的收藏夹。这个网络收藏夹做到了和浏览器的整合，而且提供了了强大的查询、共享机制。访问我的收藏夹也变得如此简单：</p>
<p><a href="http://del.icio.us/hesicong2007" target="_blank" rel="noopener">http://del.icio.us/hesicong2007</a></p>
<p>值的一提的是，这个域名取得很帅！del.icio.us，通过点分割单词以后的域名很好记，也正好符合域名注册的需要，更重要的是只需要记住delicious这个单词，外加一个你的用户名就可以访问到收藏夹了……相当人性化的设计啊！</p>
</div></article></div></div></div><div id="sidebar" class="left"><div id="about-panel"><div class="info"><div class="title">贺思聪</div><div class="bio">《爬虫实战：从数据到产品》作者，国内首个机票价格历史及预测小程序“爱飞狗旅行”作者，极客、架构师、大数据玩家。</div></div><img src="/images/avatar.png" class="avatar"></div><div id="friend-links-panel"><div class="panel-title"><p>LINKS</p></div><a href="http://github.com/derekhe" target="_blank" class="link-item"><div class="link-container"><div class="site-name">GitHub</div><div class="site-desc">http://github.com/derekhe</div></div></a><a href="http://www.jianshu.com/u/b1e713e56ea6" target="_blank" class="link-item"><div class="link-container"><div class="site-name">简书</div><div class="site-desc">http://www.jianshu.com/u/b1e713e56ea6</div></div></a><a href="https://www.linkedin.com/in/sicong-he-56a95437/" target="_blank" class="link-item"><div class="link-container"><div class="site-name">LinkedIn</div><div class="site-desc">https://www.linkedin.com/in/sicong-he-56a95437/</div></div></a></div></div></div><div class="clear"></div></main><footer class="footer-container"><div class="paginator"><a href="/page/91/" class="prev">PREV</a><a href="/page/93/" class="next">NEXT</a></div><div class="copyright"><p>© 2008 - 2019 <a href="http://www.april1985.com">贺思聪</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/AngryPowman/hexo-theme-prontera" target="_blank">hexo-theme-prontera</a>.</p></div></footer><script>var _mtac = {}; (function() {     var mta = document.createElement("script"); mta.src = "http://pingjs.qq.com/h5/stats.js?v2.0.2";    mta.setAttribute("name", "MTAH5");    mta.setAttribute("sid", "500490740");    var s = document.getElementsByTagName("script")[0];    s.parentNode.insertBefore(mta, s);})();</script></body></html>