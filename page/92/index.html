<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="aZ679hf2Rw"><title> 我是思聪</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/prontera.css"><link rel="search" type="application/opensearchdescription+xml" href="http://www.april1985.com/atom.xml" title="我是思聪"><!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-129409069-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129409069-1');
</script>


<script>
  (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();
  </script></head><body><header class="feature-header"><nav class="component-nav"><ul><div class="logo-container"><a href="/"><h2 class="title">我是思聪</h2></a></div><a href="/" target="_self" class="li component-nav-item"><p>现在</p></a><a href="/archives" target="_self" class="li component-nav-item"><p>曾经</p></a><ul class="shortcut-icons"><a href="https://github.com/derekhe" target="_blank"><img src="/images/github.svg" class="icon"></a><a href="/atom.xml" target="_blank"><img src="/images/rss.svg" class="icon"></a></ul></ul></nav></header><main class="container"><div id="body-container"><div id="post-list" class="left"><div class="home post-list"><div class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/post/2007-06-21-msdn-library-6-e69c88-chinese-version-download/" class="post-title-link">MSDN Library 6月中文版下载</a></h2><div class="post-info">Jun 21, 2007</div><div class="post-content"><p>地址<br><a href="http://download.microsoft.com/download/2/0/3/203b7183-b107-4c5d-a546-c4eb1b0dbccd/MSDVCHSDVDX1370482.img" target="_blank" rel="noopener">http://download.microsoft.com/download/2/0/3/203b7183-b107-4c5d-a546-c4eb1b0dbccd/MSDVCHSDVDX1370482.img</a></p>
</div></article></div><div class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/post/2007-06-16-will-graduate/" class="post-title-link">就要毕业了</a></h2><div class="post-info">Jun 16, 2007</div><div class="post-content"><p>28号，全体滚蛋……今天我倒是提前把大多数的东西的搬回家了。我没有卖书的习惯，现在还有1995年的电脑报的合订本，除了一些实在不想用的教科书卖了以外，很多杂志都保留着，这次的数好多书啊，垒起来都有4米多高，两个好友帮我搬了一些到车上，爸爸开车送回来的。回来了发现没有地方放书了，书架已经塞满了，没地方放了……~</p>
<p>还有十多天功夫，4年的同学就要离开了，少数的留下读研，更多数的是奔赴工作岗位，正式跨入社会了。很难想想在十天后的心情，抑或是高兴抑或是悲伤。时间依然向前，大学生活也便成为了历史。当毕业生离校手续表拿到手里的时候，感觉总是那样的别扭。偶尔打开抽屉看到高考录取通知书的时候，仿佛觉得我才来学校，然而就没有几天就要离开了，时间真是快啊。</p>
<p>遗憾自己的文采很次，没法写的那样的感人和蓝调。上个星期把相机带到学校了，不知道在最后，能用相机记录下些什么呢？</p>
</div></article></div><div class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/post/2007-06-10-i-still-remember-the-summer-you-and-me/" class="post-title-link">I STILL REMEMBER - THE SUMMER - YOU AND ME</a></h2><div class="post-info">Jun 10, 2007</div><div class="post-content"><p>毕业前夕<br>记忆中<br>还有那年<br>你我的影子<br><a href="/images/2007-6-10/IMG_0934-RESIZED.jpg"></a><img src="/images/2007-6-10/image/thumb/IMG_0934-RESIZED.jpg" alt></p>
</div></article></div><div class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/post/2007-06-08-play-games-these-days/" class="post-title-link">这几天玩游戏</a></h2><div class="post-info">Jun 8, 2007</div><div class="post-content"><p>论文写完了，PPT做完了，程序不想写了，无聊了，就玩游戏了~</p>
<p>装上最新的“蜘蛛侠3”游戏，玩了3天时间，9个多小时基本上就搞定了。画面质量还算中等，令人印象比较深刻的是其大量使用的凹凸贴图，爬到墙上的时候就会发现纹理很清晰，怪不得这个游戏最低配置是Geforce 6系列的，在我这个6600GT上只能开800X600其他全低。但是其实开到最高也没有感觉游戏画面有多少的进步，反而是帧数下降得相当厉害。落后拉~</p>
<p>蜘蛛侠3的动作做的挺好的，操作也比较容易上手，前提是图像要流畅……~要不然一吐丝，一个转向，人都不知道飞到哪儿去了……整个游戏玩下来基本上还是保持在20帧附近吧，很多场景的相当之不流畅，唉。之前有一个化学工厂的场景，也就是一秒钟一幅画的水平，也没有觉得画面有多么的复杂。开一个闸门的时候，望着远处的城市我就心酸啊，1秒钟一幅画，我开闸要开到何时啊！重试很多次以后终于放弃了。换了最新的94.71驱动，进去玩，结果就对了。</p>
<p>打沙怪的时候才心烦，第一次哈瑞打沙怪的时候就是一帧一帧的像是放幻灯片，然后这个时候还要你一系列的按键……如果按错了，还得从头再来……！！天啊，简直就是折磨人啊！后来一怒之下把驱动程序换成了NVIDIA给测试人员玩的驱动，结果……<del>基本上还可以玩了，应该说是基本流畅的玩！！！玩个游戏换了两次驱动…………………………</del></p>
<p>最后通关之前和毒蜘蛛玩的时候才造孽啊，好卡啊，动作都不到位，基本上保持在5幅画面每秒吧…………</p>
<p>终于还是通关了，卸载了，再也不玩了，虽然情节很棒，可是……真不如看漫画。</p>
<p>卸载之后又把最新的古墓丽影10周年纪念版给装上了，太搞笑了，4个G的游戏，结果基本剧情和一代差不多，隐隐约约都有印象的，图像我就不说什么了，劳拉看来也是真的老了，还不如老的一代，真是悲哀啊，EIDOS估计再也拿不出什么好玩的玩意儿给人了吧！20分钟时间，体验了第一个关卡就把它删除了，实在是无聊…………………………</p>
<p>这下没有游戏玩了，不玩了，该研究什么研究什么去</p>
</div></article></div><div class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/post/2007-06-06-openscenegraph-notes-c-cli-to-write-managed-scene-class/" class="post-title-link">OpenSceneGraph 笔记--C++/CLI写托管Scene类</a></h2><div class="post-info">Jun 6, 2007</div><div class="post-content"><p>最近学了C++/CLI，也写了一些小玩意儿体验了它的强大，昨天开始筹划将以前的弯管机的模拟程序用C++/CLI重写。</p>
<p>基本思路是将底层3D部分和上层GUI图形界面部分大体分离。最原始的做法是写一个C++的类，然后定义一些接口，然后用C++/CLI写一个Wrapper，然后用C#进行调用。这种做法其实不是很好，增加了很大的工作量，而且在写Wrapper的时候难免有很多重复性的赋值代码。</p>
<p>第二种思路就是直接用C++/CLI开始写，将Native部分和Managed部分合并在一块儿写。当然C++/CLI有一些限制，不能在托管类里面直接嵌套非托管类，只能有非托管类的指针等等。这个限制带来的最大的不好是osg::ref_ptr，也就是OpenSceneGraph里面的智能指针无法使用了，因为他是一个类型，不能直接嵌入到托管类里面，所以类似下面的语法是错误的：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ref</span> class ManagedClass</span><br><span class="line">&#123;</span><br><span class="line">    osg::ref_ptr <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">&#125;</span></span><br></pre></td></tr></table></figure>

<p>当然这样写是正确的：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ref</span> class ManagedClass</span><br><span class="line">&#123;</span><br><span class="line">    osg::<span class="keyword">Node</span><span class="title">* node</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这样就失去了智能指针的保护，很容易造成内存泄露，所以当务之急是需要写一个智能指针来代替osg::ref_ptr，但基本上要保持功能的不变。OpenSceneGraph的引用类都是继承与osg::Object，而osg::Object又是继承于osg::Reference。所以这些引用类都有ref()和unref()方法，用于增加和减少ReferenceCount，当ReferenceCount=0时，就自动delete了。</p>
<p>参考osg::ref_ptr并去掉这个类中不常用的部分，写了一个smart_ptr类，完成了智能指针的任务：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//! OpenSceneGraph managed smart_ptr.</span></span><br><span class="line">template</span><br><span class="line"><span class="keyword">public</span> ref <span class="class"><span class="keyword">class</span> <span class="title">smart_ptr</span></span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">typedef T element_type;</span><br><span class="line"></span><br><span class="line">smart_ptr() : _ptr(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">smart_ptr(T* ptr) : _ptr(ptr) &#123; <span class="keyword">if</span> (_ptr) _ptr-&gt;ref(); &#125;</span><br><span class="line">smart_ptr(<span class="keyword">const</span> smart_ptr% rp) : _ptr(rp._ptr) &#123; <span class="keyword">if</span> (_ptr) _ptr-&gt;ref(); &#125;</span><br><span class="line"></span><br><span class="line">~smart_ptr() &#123; <span class="keyword">if</span> (_ptr) _ptr-&gt;unref();  _ptr = <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">smart_ptr% <span class="keyword">operator</span> = (<span class="keyword">const</span> smart_ptr% rp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_ptr==rp._ptr) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">T* tmp_ptr = _ptr;</span><br><span class="line">_ptr = rp._ptr;</span><br><span class="line"><span class="keyword">if</span> (_ptr) _ptr-&gt;ref();</span><br><span class="line"><span class="comment">// unref second to prevent any deletion of any object which might</span></span><br><span class="line"><span class="comment">// be referenced by the other object. i.e rp is child of the</span></span><br><span class="line"><span class="comment">// original _ptr.</span></span><br><span class="line"><span class="keyword">if</span> (tmp_ptr) tmp_ptr-&gt;unref();</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> smart_ptr% <span class="keyword">operator</span> = (T* ptr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_ptr==ptr) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">T* tmp_ptr = _ptr;</span><br><span class="line">_ptr = ptr;</span><br><span class="line"><span class="keyword">if</span> (_ptr) _ptr-&gt;ref();</span><br><span class="line"><span class="comment">// unref second to prevent any deletion of any object which might</span></span><br><span class="line"><span class="comment">// be referenced by the other object. i.e rp is child of the</span></span><br><span class="line"><span class="comment">// original _ptr.</span></span><br><span class="line"><span class="keyword">if</span> (tmp_ptr) tmp_ptr-&gt;unref();</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//T% operator*()  &#123; return *_ptr; &#125;</span></span><br><span class="line">T* <span class="keyword">operator</span>-&gt;()  &#123; <span class="keyword">return</span> _ptr; &#125;</span><br><span class="line">T* <span class="keyword">get</span>()  &#123; <span class="keyword">return</span> _ptr; &#125;</span><br><span class="line"></span><br><span class="line">bool <span class="keyword">operator</span>!()    &#123; <span class="keyword">return</span> _ptr==<span class="number">0</span>; &#125; <span class="comment">// not required</span></span><br><span class="line">bool valid()        &#123; <span class="keyword">return</span> _ptr!=<span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">T* release() &#123; T* tmp=_ptr; <span class="keyword">if</span> (_ptr) _ptr-&gt;unref_nodelete(); _ptr=<span class="number">0</span>; <span class="keyword">return</span> tmp; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* _ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如此这般折腾以后，终于可以在托管类中间使用智能指针了：</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">ref</span> <span class="keyword">class</span> <span class="title">Scene</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line">smart_ptr gc;</span><br><span class="line">smart_ptr root;</span><br><span class="line">smart_ptr viewer;</span><br><span class="line">smart_ptr camera;</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>跨越了智能指针的障碍以后，还有很多问题有待于解决。像osg::Vec3这些常用类只能重写以便于调用。像查找节点FindNode这种函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ref <span class="class"><span class="keyword">class</span> <span class="title">NodeFound</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">String^ name;</span><br><span class="line">smart_ptr osgNode;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">NodeFound^ FindNode(String^ name)</span><br><span class="line">&#123;</span><br><span class="line">FindNodeVisitor findNodeVisitor;</span><br><span class="line">findNodeVisitor.name=MarshalString(name);</span><br><span class="line">root-&gt;accept(findNodeVisitor);</span><br><span class="line"><span class="keyword">if</span>(findNodeVisitor.node==<span class="literal">NULL</span>) <span class="keyword">throw</span> gcnew Exceptions::NodeNotFoundExpection();</span><br><span class="line"></span><br><span class="line">NodeFound^ nodeFound=gcnew NodeFound();</span><br><span class="line">nodeFound-&gt;name=name;</span><br><span class="line">nodeFound-&gt;osgNode=findNodeVisitor.node;</span><br><span class="line"><span class="keyword">return</span> nodeFound;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只能定义一个新的结构作为返回值，否则C#语言无法使用，因为它不能解析一个智能指针。……或许，还有别的方法可以用吧，比如用IntPtr这种，但可能又会脱离了智能指针的保护，变的危险起来。</p>
</div></article></div></div></div><div id="sidebar" class="left"><div id="about-panel"><div class="info"><div class="title">贺思聪</div><div class="bio">《爬虫实战：从数据到产品》作者，国内首个机票价格历史及预测小程序“爱飞狗旅行”作者，极客、架构师、大数据玩家。</div></div><img src="/images/avatar.png" class="avatar"></div><div id="friend-links-panel"><div class="panel-title"><p>LINKS</p></div><a href="http://github.com/derekhe" target="_blank" class="link-item"><div class="link-container"><div class="site-name">GitHub</div><div class="site-desc">http://github.com/derekhe</div></div></a><a href="http://www.jianshu.com/u/b1e713e56ea6" target="_blank" class="link-item"><div class="link-container"><div class="site-name">简书</div><div class="site-desc">http://www.jianshu.com/u/b1e713e56ea6</div></div></a><a href="https://www.linkedin.com/in/sicong-he-56a95437/" target="_blank" class="link-item"><div class="link-container"><div class="site-name">LinkedIn</div><div class="site-desc">https://www.linkedin.com/in/sicong-he-56a95437/</div></div></a></div></div></div><div class="clear"></div></main><footer class="footer-container"><div class="paginator"><a href="/page/91/" class="prev">PREV</a><a href="/page/93/" class="next">NEXT</a></div><div class="copyright"><p>© 2008 - 2020 <a href="http://www.april1985.com">贺思聪</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/AngryPowman/hexo-theme-prontera" target="_blank">hexo-theme-prontera</a>.</p></div></footer><script>var _mtac = {}; (function() {     var mta = document.createElement("script"); mta.src = "http://pingjs.qq.com/h5/stats.js?v2.0.2";    mta.setAttribute("name", "MTAH5");    mta.setAttribute("sid", "500490740");    var s = document.getElementsByTagName("script")[0];    s.parentNode.insertBefore(mta, s);})();</script></body></html>