<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="aZ679hf2Rw"><title> OpenSceneGraph 笔记--C++/CLI写托管Scene类 · 我是思聪</title><meta name="description" content="OpenSceneGraph 笔记--C++/CLI写托管Scene类 - 贺思聪"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/prontera.css"><link rel="search" type="application/opensearchdescription+xml" href="http://www.april1985.com/atom.xml" title="我是思聪"><!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-129409069-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129409069-1');
</script>


<script>
  (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();
  </script></head><body><header class="feature-header"><nav class="component-nav"><ul><div class="logo-container"><a href="/"><h2 class="title">我是思聪</h2></a></div><a href="/" target="_self" class="li component-nav-item"><p>现在</p></a><a href="/archives" target="_self" class="li component-nav-item"><p>曾经</p></a><ul class="shortcut-icons"><a href="https://github.com/derekhe" target="_blank"><img src="/images/github.svg" class="icon"></a><a href="/atom.xml" target="_blank"><img src="/images/rss.svg" class="icon"></a></ul></ul></nav></header><main class="container"><div id="post-container"><div class="post"><article class="post-block"><h1 class="post-title">OpenSceneGraph 笔记--C++/CLI写托管Scene类</h1><div class="post-info">Jun 6, 2007</div><div class="post-content"><p>最近学了C++/CLI，也写了一些小玩意儿体验了它的强大，昨天开始筹划将以前的弯管机的模拟程序用C++/CLI重写。</p>
<p>基本思路是将底层3D部分和上层GUI图形界面部分大体分离。最原始的做法是写一个C++的类，然后定义一些接口，然后用C++/CLI写一个Wrapper，然后用C#进行调用。这种做法其实不是很好，增加了很大的工作量，而且在写Wrapper的时候难免有很多重复性的赋值代码。</p>
<p>第二种思路就是直接用C++/CLI开始写，将Native部分和Managed部分合并在一块儿写。当然C++/CLI有一些限制，不能在托管类里面直接嵌套非托管类，只能有非托管类的指针等等。这个限制带来的最大的不好是osg::ref_ptr，也就是OpenSceneGraph里面的智能指针无法使用了，因为他是一个类型，不能直接嵌入到托管类里面，所以类似下面的语法是错误的：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ref</span> class ManagedClass</span><br><span class="line">&#123;</span><br><span class="line">    osg::ref_ptr <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">&#125;</span></span><br></pre></td></tr></table></figure>

<p>当然这样写是正确的：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ref</span> class ManagedClass</span><br><span class="line">&#123;</span><br><span class="line">    osg::<span class="keyword">Node</span><span class="title">* node</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这样就失去了智能指针的保护，很容易造成内存泄露，所以当务之急是需要写一个智能指针来代替osg::ref_ptr，但基本上要保持功能的不变。OpenSceneGraph的引用类都是继承与osg::Object，而osg::Object又是继承于osg::Reference。所以这些引用类都有ref()和unref()方法，用于增加和减少ReferenceCount，当ReferenceCount=0时，就自动delete了。</p>
<p>参考osg::ref_ptr并去掉这个类中不常用的部分，写了一个smart_ptr类，完成了智能指针的任务：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//! OpenSceneGraph managed smart_ptr.</span></span><br><span class="line">template</span><br><span class="line"><span class="keyword">public</span> ref <span class="class"><span class="keyword">class</span> <span class="title">smart_ptr</span></span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">typedef T element_type;</span><br><span class="line"></span><br><span class="line">smart_ptr() : _ptr(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">smart_ptr(T* ptr) : _ptr(ptr) &#123; <span class="keyword">if</span> (_ptr) _ptr-&gt;ref(); &#125;</span><br><span class="line">smart_ptr(<span class="keyword">const</span> smart_ptr% rp) : _ptr(rp._ptr) &#123; <span class="keyword">if</span> (_ptr) _ptr-&gt;ref(); &#125;</span><br><span class="line"></span><br><span class="line">~smart_ptr() &#123; <span class="keyword">if</span> (_ptr) _ptr-&gt;unref();  _ptr = <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">smart_ptr% <span class="keyword">operator</span> = (<span class="keyword">const</span> smart_ptr% rp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_ptr==rp._ptr) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">T* tmp_ptr = _ptr;</span><br><span class="line">_ptr = rp._ptr;</span><br><span class="line"><span class="keyword">if</span> (_ptr) _ptr-&gt;ref();</span><br><span class="line"><span class="comment">// unref second to prevent any deletion of any object which might</span></span><br><span class="line"><span class="comment">// be referenced by the other object. i.e rp is child of the</span></span><br><span class="line"><span class="comment">// original _ptr.</span></span><br><span class="line"><span class="keyword">if</span> (tmp_ptr) tmp_ptr-&gt;unref();</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> smart_ptr% <span class="keyword">operator</span> = (T* ptr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_ptr==ptr) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">T* tmp_ptr = _ptr;</span><br><span class="line">_ptr = ptr;</span><br><span class="line"><span class="keyword">if</span> (_ptr) _ptr-&gt;ref();</span><br><span class="line"><span class="comment">// unref second to prevent any deletion of any object which might</span></span><br><span class="line"><span class="comment">// be referenced by the other object. i.e rp is child of the</span></span><br><span class="line"><span class="comment">// original _ptr.</span></span><br><span class="line"><span class="keyword">if</span> (tmp_ptr) tmp_ptr-&gt;unref();</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//T% operator*()  &#123; return *_ptr; &#125;</span></span><br><span class="line">T* <span class="keyword">operator</span>-&gt;()  &#123; <span class="keyword">return</span> _ptr; &#125;</span><br><span class="line">T* <span class="keyword">get</span>()  &#123; <span class="keyword">return</span> _ptr; &#125;</span><br><span class="line"></span><br><span class="line">bool <span class="keyword">operator</span>!()    &#123; <span class="keyword">return</span> _ptr==<span class="number">0</span>; &#125; <span class="comment">// not required</span></span><br><span class="line">bool valid()        &#123; <span class="keyword">return</span> _ptr!=<span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">T* release() &#123; T* tmp=_ptr; <span class="keyword">if</span> (_ptr) _ptr-&gt;unref_nodelete(); _ptr=<span class="number">0</span>; <span class="keyword">return</span> tmp; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* _ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如此这般折腾以后，终于可以在托管类中间使用智能指针了：</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">ref</span> <span class="keyword">class</span> <span class="title">Scene</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line">smart_ptr gc;</span><br><span class="line">smart_ptr root;</span><br><span class="line">smart_ptr viewer;</span><br><span class="line">smart_ptr camera;</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>跨越了智能指针的障碍以后，还有很多问题有待于解决。像osg::Vec3这些常用类只能重写以便于调用。像查找节点FindNode这种函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ref <span class="class"><span class="keyword">class</span> <span class="title">NodeFound</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">String^ name;</span><br><span class="line">smart_ptr osgNode;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">NodeFound^ FindNode(String^ name)</span><br><span class="line">&#123;</span><br><span class="line">FindNodeVisitor findNodeVisitor;</span><br><span class="line">findNodeVisitor.name=MarshalString(name);</span><br><span class="line">root-&gt;accept(findNodeVisitor);</span><br><span class="line"><span class="keyword">if</span>(findNodeVisitor.node==<span class="literal">NULL</span>) <span class="keyword">throw</span> gcnew Exceptions::NodeNotFoundExpection();</span><br><span class="line"></span><br><span class="line">NodeFound^ nodeFound=gcnew NodeFound();</span><br><span class="line">nodeFound-&gt;name=name;</span><br><span class="line">nodeFound-&gt;osgNode=findNodeVisitor.node;</span><br><span class="line"><span class="keyword">return</span> nodeFound;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只能定义一个新的结构作为返回值，否则C#语言无法使用，因为它不能解析一个智能指针。……或许，还有别的方法可以用吧，比如用IntPtr这种，但可能又会脱离了智能指针的保护，变的危险起来。</p>
</div></article></div></div></main><footer class="footer-container"><div class="paginator"><a href="/post/2007-06-08-play-games-these-days/" class="prev">上一篇</a><a href="/post/2007-06-04-graduation/" class="next">下一篇</a></div><div class="copyright"><p>© 2008 - 2020 <a href="http://www.april1985.com">贺思聪</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/AngryPowman/hexo-theme-prontera" target="_blank">hexo-theme-prontera</a>.</p></div></footer><script>var _mtac = {}; (function() {     var mta = document.createElement("script"); mta.src = "http://pingjs.qq.com/h5/stats.js?v2.0.2";    mta.setAttribute("name", "MTAH5");    mta.setAttribute("sid", "500490740");    var s = document.getElementsByTagName("script")[0];    s.parentNode.insertBefore(mta, s);})();</script></body></html>