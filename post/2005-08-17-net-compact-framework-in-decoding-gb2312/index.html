<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="aZ679hf2Rw"><title> .NET Compact Framework中解码GB2312 · 我是思聪</title><meta name="description" content=".NET Compact Framework中解码GB2312 - 贺思聪"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/prontera.css"><link rel="search" type="application/opensearchdescription+xml" href="http://www.april1985.com/atom.xml" title="我是思聪"><!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-129409069-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129409069-1');
</script>


<script>
  (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();
  </script></head><body><header class="feature-header"><nav class="component-nav"><ul><div class="logo-container"><a href="/"><h2 class="title">我是思聪</h2></a></div><a href="/" target="_self" class="li component-nav-item"><p>现在</p></a><a href="/archives" target="_self" class="li component-nav-item"><p>曾经</p></a><ul class="shortcut-icons"><a href="https://github.com/derekhe" target="_blank"><img src="/images/github.svg" class="icon"></a><a href="/atom.xml" target="_blank"><img src="/images/rss.svg" class="icon"></a></ul></ul></nav></header><main class="container"><div id="post-container"><div class="post"><article class="post-block"><h1 class="post-title">.NET Compact Framework中解码GB2312</h1><div class="post-info">Aug 17, 2005</div><div class="post-content"><p>昨天在制作“掌上IP通”调用纯真IP数据库的时候，遇到了GB2312解码的问题。</p>
<p>我想，在.NET平台上本来可以用 System.Text.Encoding.GetEncoding(“GB2312”)得到GB2312的解码器的，在.NET Compact Framework中也可以使用这个方法。查阅MSDN，也确实能够支持。但十分遗憾的是，当在PDA上执行此条语句的时候，返回的却是null。如果直 接使用System.Text.Encoding.GetEncoding(“GB2312”).GetString方法的话，会抛出一个 PlatformNotSupport异常。</p>
<p>后查询到MSDN关于这个问题的解答(详见<a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dv_evtuv/html/etcondeviceprojectglobalization.asp" target="_blank" rel="noopener">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dv_evtuv/html/etcondeviceprojectglobalization.asp</a>)
Encoding<br>The .NET Compact Framework supports character encoding on all devices: Unicode (BE and LE), UTF8, UTF7, and ASCII.</p>
<p>There is limited support for code page encoding and only if the encoding is recognized by the operating system of the device.</p>
<p>The .NET Compact Framework throws a PlatformNotSupportedException if the a required encoding is not available on the device.</p>
<p>If the optional component Mlang.dll is on the device, the following code pages are supported: CP 51932 (EUC-JP), CP 50220 (ISO2022JP), and CP 50221 (cslSO2022JP).</p>
<p>也就是说GB2312不受.NET Compact Framework的支持。</p>
<p>很无赖，我们无法用常规的方法来解码GB2312。在此搜索有关GB2312的文章，发现原来GB2312有一个对照表，可以和Unicode进行双向的转换。后下载到一个GB2312.TXT的对照表(请见<a href="http://www.hesicong.com/Docum/gb2312.txt" target="_blank" rel="noopener">[download id=”28”]</a>)，对照词表可以将GB2312转换成Unicode然后就可以解码了。</p>
<p>根据GB2312.txt中所述，需要将实际的编码减去0x8080，然后再查表。</p>
<p>例如“南”的GB2312编码为：0xC4CF，查表的时候减去0x8080，得到0x444F，查表得到Unicode码：0x5357。此后利用System.Text.Encoding.Unicode.GetChars()就可以得到相应的字符。</p>
<p>虽然转了一个弯，但是还是达到了目的。</p>
<p>为此，我写了一个GB2312 To Unicode Conver Table 的控制台程序，以便将GB2312.TXT转换成一个索引供查询。编码好的文件下载：<a href="http://www.hesicong.com/Docum/gb2312.dat" target="_blank" rel="noopener"></a>[download id=”29”]</p>
<p>代码如下：</p>
<figure class="highlight vbnet"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Imports</span> System.<span class="keyword">Text</span></span><br><span class="line"><span class="keyword">Imports</span> System.IO</span><br><span class="line"><span class="keyword">Module</span> Module1Module Module1</span><br><span class="line"></span><br><span class="line"> <span class="keyword">Sub</span> Main()<span class="keyword">Sub</span> Main()</span><br><span class="line"> <span class="keyword">Dim</span> sr <span class="keyword">As</span> <span class="keyword">New</span> StreamReader(<span class="string">"D:gb2312.txt"</span>)</span><br><span class="line"> <span class="keyword">Dim</span> fs <span class="keyword">As</span> <span class="keyword">New</span> FileStream(<span class="string">"D:gb2312.dat"</span>, FileMode.Create)</span><br><span class="line"> <span class="keyword">Dim</span> sw <span class="keyword">As</span> <span class="keyword">New</span> BinaryWriter(fs)</span><br><span class="line"> <span class="keyword">For</span> i <span class="keyword">As</span> <span class="built_in">Integer</span> = <span class="number">1</span> <span class="keyword">To</span> <span class="number">70</span></span><br><span class="line"> sr.ReadLine()</span><br><span class="line"> <span class="keyword">Next</span></span><br><span class="line"> <span class="keyword">Do</span> <span class="keyword">Until</span> sr.EndOfStream</span><br><span class="line"> <span class="keyword">Dim</span> ss <span class="keyword">As</span> <span class="built_in">String</span>() = sr.ReadLine.Split</span><br><span class="line"> <span class="keyword">Dim</span> HEX <span class="keyword">As</span> <span class="built_in">Short</span> = <span class="built_in">CShort</span>(Val(ss(<span class="number">1</span>).Replace(<span class="string">"0x"</span>, <span class="string">"&amp;H"</span>)))</span><br><span class="line"> <span class="keyword">Dim</span> offset <span class="keyword">As</span> <span class="built_in">Integer</span> = (<span class="built_in">CInt</span>(Val(ss(<span class="number">0</span>).Replace(<span class="string">"0x"</span>, <span class="string">"&amp;H"</span>))) - &amp;H2121) * <span class="number">2</span></span><br><span class="line"> sw.BaseStream.Position = offset</span><br><span class="line"> sw.Write(HEX)</span><br><span class="line"> <span class="keyword">Loop</span></span><br><span class="line"> sw.Close()</span><br><span class="line"> <span class="keyword">End</span> <span class="keyword">Sub</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Module</span></span><br></pre></td></tr></table></figure>

<p>使用的时候将欲解码的GB2312编码减去0x8080，再减去0x2121(偏移)，也就是说减去0xA1A1，然后将 FileStream.Position指向所得到的结果的2倍(两个字节一个码)并读取一个Int16就可以得到对应的Unicode码。下面是我在掌 心IP通中的一段代码。</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GB2312ToUnicode</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">private</span> FileStream fs;</span><br><span class="line"><span class="keyword">private</span> BinaryReader br;</span><br><span class="line"><span class="keyword">public</span> GB2312ToUnicode(string <span class="keyword">index</span>)</span><br><span class="line">&#123;</span><br><span class="line">fs=<span class="keyword">new</span> FileStream(<span class="keyword">index</span>, FileMode.Open);</span><br><span class="line">br = <span class="keyword">new</span> BinaryReader(fs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">char</span> Convert(<span class="keyword">byte</span>[] b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">index</span> = ((b[<span class="number">0</span>] &lt;&lt; <span class="number">8</span>) + b[<span class="number">1</span>] - <span class="number">0xa1a1</span>)*<span class="number">2</span>;</span><br><span class="line">fs.Position = <span class="keyword">index</span>;</span><br><span class="line"><span class="keyword">int</span> tmp = (<span class="keyword">int</span>)br.ReadInt16() &amp; <span class="number">0xFFFF</span>;</span><br><span class="line"><span class="keyword">return</span> System.Convert.ToChar(tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~GB2312ToUnicode()</span><br><span class="line">&#123;</span><br><span class="line">br.Close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就方便的得到了GB2312的解码器。</p>
<p>另外，如果打开GB2312.DAT文件可以看到，数据中有很多的0。本来可以通过重新计算偏移的方法来压缩数据，但是考虑到PocketPC上面的速度，尤其是要解码大量文本的时候，就只好用空间换取时间了。</p>
</div></article></div></div></main><footer class="footer-container"><div class="paginator"><a href="/post/2005-08-21-little-information-3gpp-document-naming/" class="prev">上一篇</a><a href="/post/2005-08-16-upgrade-time-into-a-small-sense-of-0-hours/" class="next">下一篇</a></div><div class="copyright"><p>© 2008 - 2020 <a href="http://www.april1985.com">贺思聪</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/AngryPowman/hexo-theme-prontera" target="_blank">hexo-theme-prontera</a>.</p></div></footer><script>var _mtac = {}; (function() {     var mta = document.createElement("script"); mta.src = "http://pingjs.qq.com/h5/stats.js?v2.0.2";    mta.setAttribute("name", "MTAH5");    mta.setAttribute("sid", "500490740");    var s = document.getElementsByTagName("script")[0];    s.parentNode.insertBefore(mta, s);})();</script></body></html>